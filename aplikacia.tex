\chapter{Motivácia a spôsob prekladania kódu}%TODO preco a ako to chceme prelozit
\NEW{}
V práci sa sústredíme na funkčnosť a udržateľnosť kódu. Zaujíma nás najmä tá časť aplikácie, ktorá zabezpečuje funkcionalitu pre používateľa. Prostredie, v ktorom aplikácia beží (prehliadač, server, prihlásenie, \ldots) v práci neriešime, na tieto časti kódu sme využili boilerplate %TODO preklad
od \emph{este} \cite{Este} pre kód v \JS{}. 
V aplikácii v jazyku Dart sme túto funkcionalitu zabezpečili vlastnými pomocnými knižnicami a nástrojom \emph{pub}.
%Téma na túto prácu vznikla z praxe. 

\section{Motivácia}
\NEW{}
\paragraph{Zmena programovacieho jazyka}
Existujúca aplikácia vyvíjaná v jazyku Dart už má svoje zabehnuté prostredie v ktorom beží. Dart je výborný jazyk pre začínajúci tím (má voliteľnú kontrolu typov, pomerne presnú štruktúru), už však nie je taký živý a knižnice ku nemu vznikajú pomaly a v obmedzenom množstve. 
Taktiež podpora vývojových prostredí je menšia a slabšia. V čase, keď jazyk Dart začínal, existovalo preň vývojové prostredie. Dnes existuje viacero programov s podporou Dart-u. 

JavaScript je skriptovací jazyk, ktorý beži v prehliadači priamo. Nevýhodou Dart-u je nutnosť kompilovať tento jazyk do JavaScript-u, ktorý vie byť vykonaný prehliadačom. \JS{} je pomerne nová verzia JavaScript-u, preto nie je ešte plne podporovaný všetkými prehliadačmi. Je nutné tento jazyk transpilovať do staršej verzie (napríklad ES5 má dobrú podporu). Má však potenciál bežať v budúcnosti rýchlejšie.
Práve z toho dôvodu bola snaha presunúť už existujúci kód do jazyka JavaScript, ktorý je v súčastnosti veľmi živý jazyk podporovaný mnohými komunitami. 
%Pri vývoji aplikácie v JavaScripte sme sa zamerali na lean vývoj, preto sme si ako základ aplikácie zvolili balík knižníc \cite[este]{Este}.%TODO

Aj keď majú tieto jazyky isté odlišnosti, sú navzájom veľmi podobné a bolo jednoduché prispôsobiť sa jazyku JavaScript po skúsenostiach s Dartom.
Rozdiel bol viac v použitých knižniciach ako v samotných jazykoch.

\paragraph{Jazykové mutácie}
Veľký prínos sme zaznamenali v spravovaní jazykových mutácií aplikácie. Knižnica \emph{react-intl} vie vyexportovať nepreložené a nové frázy, aj keď nie sú uložené v jednom súbore, čo sprehľadňuje správu týchto fráz.

\paragraph{Zmena návrhového vzoru}
\NEW{}
Flux je pomerne jednoduchý návrhový vzor. Ako sme spomenuli vyššie, Redux-ová aplikácia je aj Flux-ová. Pridáva však pravidlá a obmedzenia, vďaka ktorým sa stáva aplikácia viac prehľadná a lepšie krokovateľná. Pri Reduxe je jasné kedy a aké dáta sa zmenili. Redux vďaka čistým funkciám a zoznamu vykonaných akcií poskytuje možnosť simulovať celý beh v ľubovolnom čase, zopakovať niektoré kroky s rovnakým stavom aplikácie alebo sa vrátiť v čase dozadu.

V pôvodnej aplikácii sme robili dotazy na server z jednotlivých storov. V novej aplikácii sme toto nemohli nechať na reducer, pretože by to porušilo princípy Redux aplikácie. Preto tieto dotazy robí middleware. Pri písaní novej aplikácie ma tento vzor naučil zamýšľať sa nad tým, ktorá akcia je príčinou takéhoto dotazu na server, pretože bolo potrebné počúvať práve na ňu.

%LISTING
%\input lstDotazNaServer.tex

\paragraph{Entity}%TODO vhodne umiestniť
V aplikácii sme spravili jednu zásadnú zmenu so štruktúrou vnútorného stavu aplikácie. V pôvodnej aplikácii boli entity (objednávky, protokoly) priamo v stave pod daným kľúčom. 
V Reduxovej aplikácii sme ich presunuli do samostatnej vetvy, kde sú jednotlivé entity uložené pod typom a identifikačným reťazcom. Potom v stave namiesto zoznamu celých entít existuje len zoznam ID. 
Túto zmenu sme spravili preto, aby bolo jednoduchšie upravovať jednotlivé entity. Teda aj keď sa na danú entitu odkazujeme na viacerých miestach, jej dáta upravujeme len na jednom. Túto funkcionalitu nám pomáha udržiavať knižnica \emph{normalizr}.
Tiež pri veľkom množstve entít to uľahčilo vyhľadávanie danej entity podľa ID (netreba iterovať cez pole entít, stačí sa pozrieť do mapy pod správnym kľúčom).

\paragraph{Hot reloading}%TODO preklad
\NEW{}
Program \emph{pub}, ktorý zabezpečuje beh programu v kóde Dart v prehliadači nepodporuje hot-reloading. Pri každej zmene treba obnoviť stránku.

Pre JavaScript hot reloading v našom kóde zabezpečuje knižnica \emph{webpack} \cite{webpack}.

Vyvíjanie aplikácie s možnosťou hot reloading ponúka rýchlejšie výsledky a lepší zážitok z programovania :).

\section{Ako preložiť všetky časti kódu}

\NEW{}
V nasledujúcej časti popíšeme návrh, ako by sa mohli preložiť jednotlivé časti kódu v jazyku Dart s použitím návrhového vzoru Flux do kódu v jazyku \JS{} s použitím návrhového vzoru Redux.

\subsection{Komponenty}

\paragraph{Komponenty v Darte s Flux-om}
V Dartovej applikácií sú všetky komponenty triedami.

\paragraph{Komponenty v JavaScripte s Redux-om}
V JavaScriptovej aplikácii máme dva typy komponentov: kontajnerové a prezenčné. 

Prezenčné sú jednoduchšie, priamočiarejšie. Všetky parametre, ktoré potrebujú, by mali dostať od volajúceho komponentu (vrátane funkcií na vytváranie akcií). Nemajú prístup ku celému stavu aplikácie. Mali by to byť hlavne znovu použiteľné komponenty (napríklad riadok tabuľky).
%TODO ukážka prezenčného komponentu

Kontajnerové komponenty sú o niečo zložitejšie. Majú prístup ku celému stavu aplikácie, z ktorého si vyberajú len potrebné časti. Na to nám pomáha funkcia \emph{connect} z knižnice \emph{react-redux}. Kontajnerový komponent vyzerá podobne ako prezenčný, tiež všetko vykresľuje len zo svojich parametrov. 
Funkcia \emph{connect} tvorí medzivrstvu medzi týmto komponentom a jeho exportovaným variantom. Do tohoto komponentu doplní potrebné dáta zo stavu. Tieto komponenty sú však menej univerzálne, keďže sú viazané na konkrétne dáta zo stavu.

\subparagraph{Connect}
\label{func:connect}
Funkcia \emph{connect} akceptuje dva argumenty. Jedným z nich je funkcia, ktorá namapuje stav na argumenty komponentu. Druhý je funkcia, ktorá namapuje dispatcher na akcie. %voliteľné - null
(\emph{Connect} môžeme použiť aj na zmenu vlastných parametrov pre prezenčné komponenty, avšak to väčšinou nie je žiadúce, pretože to komplikuje logiku kódu. Do prezenčných komponentov by sme mali posúvať už len hotové dáta na vykreslenie. Predídeme tak aj zbytočnému prekresľovaniu kódu kôli zmeneným vlastným dátam.)
%TODO ukážka connect funkcie

%TODO nezalamovat za predlozkami
\paragraph{Zmeny}
\NEW{}
Úlohy komponentov:\\
%0.4\linewidth
\begin{tabular}{| p{4cm} | p{5cm} | p{5cm} |}
 \hline
   Vlastnosť & implementácia v Dart s Flux-om & implementácia v \JS{} s Redux-om \\
  \hline
  \hline
   vykreslenie komponentu, prekreslenie pri zmene dát & 
   knižnica \emph{tiles} &
   knižnica \emph{redux} \\
  \hline
   jazykové mutácie & 
   vlastná knižnica?? \TODO{} & 
   knižnica \emph{react-intl} \\
  \hline
   zistenie aktálnej routy & 
   manipulator.router.url, knižnica \emph{route\_hierarchical} (vlastná verzia?) \TODO{} & 
   knižnica \emph{react-router} poskytuje pri vykreslení dáta o aktuálnej route \\
  \hline
   vytvorenie novej akcie & 
   dispatch, dispatchAsync, knižnica \emph{flux} (vlastná?) \TODO{} & 
   kontajnerový komponent s funkciou \emph{connect} \ref{func:connect} \\
  \hline
   zmena routy & 
   dispatch(\{type: ROUTE, \ldots\}) & 
   komponent Link z knižnice \emph{react-router} \\
  \hline
 \end{tabular}

%LISTING
%\input komponentyListing.tex

Stále platí, že komponenty nesmú meniť stav, jediný spôsob, ako by mali mať možnosť toto uskutočniť je vytvorenie akcie.

Komponent v JavaScripte v Reduxe (Reacte) %???
definujeme ako funkciu s voliteľnými pomenovanými parametrami (v kučeravých zátvorkách). %s veľkým písmenom, vraciame objekt v zátvorkách
Komponent môže vrátit len jeden objekt, nie pole objektov. Tento komponent však môže obsahovať viacero komponentov na jednej úrovni.
Ak definujeme tomuto objektu okrem parametrov aj nejaký obsah, je dostupný cez parameter children.%TODO ukážka volania komponentu

V ukážke \ref{lst:dartComponent} je komponent v jazyku Dart a v ukážke \ref{lst:jsComponent} je ten istý komponent v jazyku \JS{}.

\subparagraph{Gettery} \NEW{}
V Dartovom kóde sme častokrát využívali gettery \ref{par:getters} (getter v čase zavolania vyhodnotí výraz, ktorý reprezentuje). Môžeme ku getterom pristúpiť troma spôsobmi: 
\begin{itemize}
  \item definujeme tieto výrazy ako funkcie mimo komponentu
  \item v komponente, kde sme chceli použiť getter, si spravíme pomocnú premennú, do ktorej uložíme výsledok vyhodnoteného výrazu
  \item na miesto volania getteru vložíme priamo výraz z gettera
\end{itemize}

Getter mal za úlohu sprehľadniť kód, keďže jeho volanie bolo jednoduché.
V ukážke \ref{lst:jsComponent} z aplikácie je použitý prvý prístup. Tento zachováva pôvodnú štruktúru kódu. Tento kód sa dá ešte refaktorovať použitím tretieho spôsobu nahradenia getterov. V ukážke sme však zvolili prvý, aby bola zachovaná názornosť prekladania kódu.

\subparagraph{Mixiny}
V Dartovom kóde sme časti kódu, ktoré sa opakovali, dali do mixinov \ref{par:mixins}. V JavaScripte s Reduxom však chceme preferovať vykreslenie čistými funkciami, čo podporuje aj ideológia knižnice \emph{react}. Preto sme z mixinov spravili malé pomocné knižnice s čistými funkciami, ktoré len jednoducho importujeme. Často tieto mixiny využívali práve dáta danej triedy (komponentu) pomocou getterov. Toto ale pri knižniciach nie je možné, keďže komponent nezdieľa svoje dáta s knižnicami, ktoré používa.

\subparagraph{Perzistentné štruktúry} \NEW{}
Štruktúry/dáta v kóde môžeme udržať perzistentné dvoma spôsobmi. 
Jedným je dôkladné kontrolovanie kódu, ktorý píšeme. Pri akomokoľvek úmysle zmeniť tieto dáta vytvoríme novú inštanciu.
Druhým je použitie vhodnej knižnice, ktorá túto správu a kontrolu bude robiť za nás.

Perzistentné štruktúry sme v jazyku Dart používali s pomocnou knižnicou \emph{vacuum\_persistent}. V jazyku \JS{} sme sa rozhodli používať prvú možnosť. Rozhodli sme sa tak vďaka jednoduchosti používania rozširovacieho operátora \ref{par:spreadOp}, ktorý je v jazyku JavaScript dostupný od verzie ES6.

\subsection{Story}
Story v pôvodnej aplikácii spracúvajú všetky akcie. Každý store má zoznam akcií, na ktoré počúva. Okrem toho počúva aj na zmenu routy.

Úlohy store:\\
\begin{tabular}{| p{4cm} | p{5cm} | p{5cm} |}
 \hline         % na vrchu tabuľky je čiara
   Vlastnosť & implementácia v Dart s Flux-om & implementácia v \JS{} s Redux-om \\
  \hline
  \hline
   uchováva a mení vnútorný stav aplikácie & 
   insert, insertInOrCreate &
   reducer \\
  \hline
   komunikácia so serverom & 
   dispatchAsync & 
   middleware \\
  \hline
   zmena routy & 
   dispatchRoute, dispatch(GOROUTE) & 
   komponent Link z knižnice \emph{react-router} \\
  \hline
   vytvorenie novej akcie & 
   dispatch & 
   vyhnúť sa tomu, použiť reducery vo vhodnom poradí \\%v \emph{configureReducer.js}
  \hline
 \end{tabular}

\TODO{} (počúvanie na zmenu routy - aj to je len typ akcie)

\subsection{Akcie}
\TODO{}(prerobit, preformulovat!)

Každá akcia má typ a nejaké prídavné dáta. %niekoľko centrálnych skladísk akcií
Typ akcie je string, dáta: predtým niekoľko polí, teraz jeden objekt \emph{payload}(\TODO{} toto nie je rozdiel medzi flux a redux!). Ľahká kompozícia aj dekompozícia dát. %špec. súbor na akcie?

action creators %TODO !!!

Na akcie počúvajú story aj middlewares.

\input openSourceKniznice.tex
%rada by som tieto dve časti vymenila a ukážky dala ako subsection pod AKO

\section{Súborová štruktúra aplikácie}
\NEW{}
\paragraph{Flux}
V aplikácii, ktorá bola v návrhu Flux, sme mali súbory usporiadané podľa typu súboru, teda zvlášť Story a zvlášť Komponenty. Pre akcie sme nemali žiaden priečinok, boli definované len konštanty, z ktorých sa typy akcií skladali.

Tento prístup bol výhodný ak sme hľadali súbor podľa funkcionality.

\paragraph{Redux}
V aplikácii s návrhovým vzorom Redux sme zvolili usporiadanie súborov podľa toho, akej časti stavu sa venujú. Teda ak robíme úpravu jednej entity, meníme len jeden priečinok z celej aplikácie.

Výhodou tohoto prístupu je, že máme všetky súbory týkajúce sa jednej problematiky na jednom mieste.
Akcie definujeme v jednom súbore. Máme tak naraz prehľad o všetkých scenároch, aké sa môžu na stránke udiať.

\TODO{} (rozdeliť na common a browser?)

\section{Ukážky kódu}

\input lstDotazNaServer.tex
\input komponentyListing.tex

