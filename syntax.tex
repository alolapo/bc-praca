\chapter{Programovacie jazyky Dart a \JS{}}

\label{kap:jazyky} % id kapitoly pre prikaz ref

V tejto kapitole si povieme niečo o programovacích jazykoch Dart a \JS{}, s ktorými budeme počas celej práce robiť.

\section{Dart}
\label{sec:dart}
V tejto sekcii si predstavíme hlavné črty programovacieho jazyka Dart. Dart je objektovo orientovaný programovací jazyk. Je založený na definovaní tried, kde trieda môže dediť od najviac jednej inej triedy. 
Jazyk Dart je voliteľne typovaný. (Túto vlastnosť si bližšie popíšeme v podkapitole \ref{subsec:typy}). 
%(+ supports reified generics?).
Informácie do tejto kapitoly boli čerpané najmä zo špecifikácie jazyka\cite{DartLanguage}.

\subsection{Triedy}
Trieda (\emph{class}) definuje formu a správanie určitej množine objektov. Tieto objekty nazývame inštancie (\emph{instance}) danej triedy. 
Trieda môže byť definovaná deklaráciou samotnej triedy, alebo pomocou mixinov.

Trieda má konštruktory a členy (členy danej inštancie a statické členy). Členy sú metódy, premenné, gettery a settery. 

%superclass
\paragraph{Nadtrieda}
Každá trieda má práve jednu nadtriedu (\emph{superclass}) okrem triedy \emph{Object}, ktorá nemá. Táto nadtrieda sa uvádza za kľúčovým slovom \emph{extends}, alebo je určená implicitne ako \emph{Object}. %with - mixin
Daná trieda dedí od nadtriedy všetky dostupné členy danej inštancie, ktoré neboli preťažené (\emph{override}).

%interface
\paragraph{Rozhranie}
Trieda môže implementovať (\emph{implements}) niekoľko rozhraní (\emph{interface}). Rozhranie definuje, ako by sa malo pracovať s objektom. 
Má metódy, gettery, settery a množinu \uv{nadrozhraní}, ktoré rozširuje.

%Mixins
\paragraph{Mixin}
\label{par:mixins}
Mixin opisuje rozdiel medzi triedou a jej nadtriedou. Mixin je vždy odvodený od deklarácie existujúcej triedy.
Mixin môžeme použiť pri definovaní novej triedy pomocou kľúčového slova \emph{with M} (kde M je mixin).
Mixin je užitočný v prípadoch, kedy viacerým zdanlivo nezávislým triedam chceme pridať rovnakú funkcionalitu.

%abstract
\paragraph{Abstraktná trieda}
Trieda môže byť abstraktná, vtedy ju definujeme kľúčovým slovom \emph{abstract}. Takáto trieda nemusí mať implementované všetky metódy. Mixiny sú abstraktné triedy.

%constructor
\paragraph{Konštruktor}
Konštruktor triedy je špeciálna funkcia, ktorá vytvára inštanciu triedy. Volá sa rovnako ako trieda, ktorej prislúcha. 
Ak nie je špecifikovaná, volá sa v implicitnom konštruktore konštruktor nadtriedy. % máme niekde generatíve constructors? (this.id)
% factory constructors? constant constructors?

\subsection{Typy}
\label{subsec:typy}
Programovací jazyk Dart podporuje voliteľné typovanie založené na typoch rozhrania.

\paragraph{Statické typy}
Statické typy sú použité pri deklarovaní premenných, pri definícii návratových hodnôt funkcií a v ohraničení typu premenných. 
Tieto statické typy sú použité iba pri statickej kontrole a v kontrolovanom móde. Na produkčný mód nesmú mať žiaden vplyv.
Medzi základné typy patria:
\begin{itemize}
\item konštanty (\emph{constants}): čísla (\emph{number}), booleovské premenné (\emph{bool}), reťazce znakov (\emph{string}), nulový objekt (\emph{null})
\item kolekcie viacerých prvkov: zoznamy (objekt \emph{List}), mapy (objekt \emph{Map})
\end{itemize}

Pri produkčnom móde sa všetky typy nahradia jednotným typom \emph{dynamic}. Ten označuje neznámy typ.

\paragraph{Dynamic}
Typ \emph{dynamic} má definovanú každú možnú operáciu s všetkými možnými počtami parametrov. Návratová hodnota týchto operácií je vždy \emph{dynamic}. Chceme tak zabezpečiť, aby nám typ \emph{dynamic} nikdy nevrátil chybovú hlášku o nesprávnom type. \emph{Dynamic} je považovaný za typový objekt, aj keď to nie je trieda.

\paragraph{Void}
Typ \emph{void} možno použiť len ako návratovú hodnotu funkcie. \emph{Void} nie je považovaný za typový objekt. Môže oznamovať upozornenia v kontrolovanom móde, ak funkcia vracia inú hodnotu ako \emph{null}.

\paragraph{Null}
Rezervované slovo \emph{null} označuje null-ový objekt. Je to jediná inštancia triedy \emph{Null}. Rozširovanie, implementovanie alebo použitie tejto triedy ako mixin spôsobí chybu pri kompilácii (\emph{compile-time error}).
Volanie akejkoľvek metódy na objekte \emph{null} spôsobí chybu.

\paragraph{This}%velmi divotvorna konstrukcia
Slovo \emph{this} označuje aktuálne používanú inštanciu triedy, s ktorou pracujeme. Statický typ \emph{this} je potom rozhranie tejto triedy.
%Slovo \emph{this} označuje cieľ vyvolania aktuálnej inštancie. 
%Statický typ pre \emph{this} je rozhranie bezprostredne ohradenej triedy.

\subsection{Premenné}
Premenné sú úložiská v pamäti. Neinicializovaná premenná má hodnotu \emph{null}.

\emph{Static variable} je taká premenná, ktorá nie je asociovaná s konkrétnou inštanciou, ale s celou knižnicou alebo triedou.

\emph{Final variable} je taká premenná, ktorá je zviazaná s konkrétnym objektom od jej deklarácie. Spôsobuje \emph{static warning} ak je inicializovaná aj v konštruktore. Spôsobuje \emph{compile-time errror} ak nie je inicializovaná pri deklarácii.
\emph{Constant variable} je implicitne \emph{final}.
%opak final je mutable

Ak deklarácia nešpecifikuje typ premennej, tak je \emph{dynamic}, čo predstavuje neznámy typ.

\paragraph{Gettery a settery}
Ku premenným pristupujeme pomocou prirodzených getterov a setterov. 
Getter je funkcia bez argumentov, ktorá v čase zavolania vyhodnotí výraz, ktorý definuje danú premennú a vráti výsledok.
Setter je funkcia s jedným argumentom, ktorá danej premennej priradí hodnotu jej argumentu. \emph{Final} premenné nemajú settery.

\subsection{Funkcie}
Funkcie predstavujú vykonateľné akcie. Funkcie pozostávajú z deklarácií, metód, getterov, setterov, konštruktorov. % a literálov.
Každá funkcia má 2 časti: popis(signature) a telo(body). Popis funkcie obsahuje formálne parametre a môže obsahovať typ návratovej hodnoty. Telo funkcie môže mať 2 tvary:
\begin{itemize}
\item blok príkazov v zložených zátvorkách (\{, \}). Ak tento blok príkazov neobsahuje príkaz \emph{return}, automaticky sa na koniec pridáva s návratovou hodnotou \emph{null}.
\item \emph{=> e}, čo je ekvivalentné \emph{\{return e;\}}
\end{itemize}
Oba bloky príkazov môžu byť vykonané synchrónne(modifikátor \emph{sync*}) alebo asynchrónne(\emph{async, async*}).

Každá funkcia má zoznam parametrov, ktorý obsahuje zoznam povinných pozičných parametrov, potom zoznam voliteľných parametrov. Voliteľné parametre môžu byť pomenované alebo pozičné ale nie obe súčasne.

Ak sa neuvedie typ návratovej funkcie explicitne, jej typ je \emph{dynamic}, alebo daná trieda, ak ide o konštruktor.

Externá funkcia(\emph{external}) je funkcia, ktorá má deklaráciu a telo funkcie na rôznych miestach v kóde. Môžu to byť napríklad funkcie implementované externe v inom programovacom jazyku alebo také, ktoré sú dynamicky generované ale ich popis je statický a známy.

\subsection{Upozornenia a chyby}%warnings and errors
Dart rozlišuje niekoľko druhov chýb. Napríklad:
\begin{itemize}
\item Kompilačné chyby (\emph{compile-time errors}) teda chyby v čase kompilácie, ktoré bránia ďalšiemu behu programu. Tieto musia byť nahlásené kompilátorom pred spustením samotného chybného kódu.
\item Statické upozornenia (\emph{static warnings}) sú chyby zistené statickou kontrolou (teda nie za behu programu). Nemajú žiaden efekt v čase behu programu.
Statická kontrola sa týka najmä konzistentnosti typov, ale neznemožňuje kompiláciu ani beh samotného programu. Statickú kontrolu by mali zabezpečovať vývojové prostredia a kompilátory.
\end{itemize}

\paragraph{Módy behu programu}
Programy môžu byť spustené v dvoch módoch:%\paragraph{...} 
\begin{itemize}
\item Checked mode (\emph{kontrolovaný mód}) - v tomto móde fungujú \emph{static warnings} aj \emph{compile-time errors}. Je vhodný na písanie kódu a ladenie programu.
\item Production mode (\emph{produkčný mód}) - ako samotný názov napovedá, tento mód je určený na beh programu u klienta. V tomto móde sa \emph{static warnings} nevyskytujú, sú tu len \emph{compile-time errors} a chyby, ktoré sa vyskytli priamo pri behu aplikácie.
\end{itemize}

\subsection{Súkromie}
Dart podporuje dve úrovne súkromia, \emph{private} (súkromný) a \emph{public} (verejný).
Objekt, ktorý je deklarovaný s kľúčovým slovom \emph{private} je súkromný, inak je každý objekt verejný. 
Tiež môžeme definovať súkromný objekt tak, že jeho názov začína podčiarkovníkom (\glqq\_\grqq). 

Programy v jazyku Dart sú organizované do knižníc. Objekt je dostupný v knižnici len ak je definovaný v danej knižnici, alebo ak je \emph{public}.

\subsection{Knižnice}
Program v jayzku Dart pozostáva z jednej alebo viacerých knižníc. Môže byť vytvorený z viacerých kompilačných jednotiek (\emph{compilation units}). Kompilačná jednotka môže byť knižnica alebo \emph{part}.
Knižnice sú jednotkami súkromia. Kód definovaný vrámci knižnice ako súkromný je dostupný len vrámci danej knižnice.

Knižnica pozostáva z množiny importov, exportov a verejne deklarovaných objektov. Tieto môžu byť triedy, funkcie alebo premenné.

\paragraph{Import}
Kľúčové slovo \emph{import} prepája knižnice. Určuje, ktoré knižnice môžu byť použité pri programovaní inej knižnice. 
\emph{Import} umožňuje explicitne povedať, ktoré objekty z kategórie \emph{public} chceme skryť, tie uvedieme za kľúčovým \emph{hide}. 
Alebo vybrať podmnožinu objektov, ktoré chceme ponechať (a ostatné sa nám skryjú) pomocou kľúčového slova \emph{show}.
Ak by sa nám mohlo stať, že názvy funkcií alebo premenných sa vo viacerých knižniciach prekrývajú (čo je problém a snažíme sa tomu zabrániť), môžeme premenovať dané objekty pomocou kľúčového slova \emph{as}. 
Podobne sa dá pomenovať aj samotná knižnica, kde potom voláme prvky knižnice nasledovne: \emph{libraryName.objectName}.

\paragraph{Export}
Kľúčové slovo \emph{export} definuje množinu objektov, ktoré sú prístupné po importovaní danej knižnice L, v ktorej sa \emph{export} nachádza. 
Môžeme exportovať množinu objektov, alebo celú knižnicu. 
Tiež môžeme obmedziť export knižnice pomocou \emph{show} a \emph{hide} rovnako, ako pri importovaní.

\paragraph{Parts}
Ak máme veľkú knižnicu, môžeme ju rozdeliť do viacerých súborov pomocou \emph{part} a \emph{part of}. 
Všetky definície objektov, aj súkromné, sú medzi týmito časťami vzájomne viditeľné.

Hlavný súbor obsahuje kľúčové \emph{part}, kde pomenuje cestu ku druhému súboru, ktorá reprezentuje časť knižnice. Tá pomenuje, ku ktorému hlavnému súboru prislúcha za kľúčovým \emph{part of}.
Importovanie ďalších knižníc potom stačí uviesť v hlavnom súbore.

\paragraph{Scripts}
\emph{Skript} sa nazýva knižnica, ktorá obsahuje funkciu \emph{main}. Takáto funkcia môže byť v jednom projekte práve jedna. Je to funkcia, ktorá sa spúšťa na začiatku programu.

\paragraph{Pub}
O to, aby boli všetky knižnice, ktoré sú importované, dostupné a aktualizované zabezpečuje špeciálny správca knižníc \emph{pub} (\emph{package manager}). 
Každá knižnica má zoznam závislostí - aké verzie cudzích knižníc používa. 
Pub vyžaduje špeciálny súbor (pubspec.yaml) obsahujúci zoznam knižníc s požadovanými verziami ku každej knižnici. Na základe tohoto súboru pracuje príkaz \emph{pub get}, ktorý stiahne potrebné zmeny.

Okrem iného spravuje \emph{pub} mená publikovaných knižníc, aby sa zabránilo kolíziám.
%TODO pub serve

\subsection{Súbežnosť}%paralelizmus 
Kód v jazyku Dart je vždy jednovláknový. Ak chceme vykonávať viac súbežných činností, používame špeciálnu entitu \emph{isolates}, ktorá má vlastnú pamäť a vlastnú kontrolu vlákna. Tieto entity medzi sebou komunikujú pomocou posielania správ, nezdieľajú žiaden stav.

Dart podporuje asynchrónnosť vykonávania programu. Kľúčovým \emph{await} odovzdáme kontrolu, pokým sa výraz za \emph{await} vyhodnotí. Ak sa nevie vyhodnotiť v čase vykonávania tejto inštrukcie, namiesto hodnoty sa vytvorí inštancia triedy \emph{Future}, za ktorú sa neskôr po dopočítaní dosadí daná hodnota výrazu.%neviem, či som to uplne dobre pochopila

%\subsection{TODO}
%kaskádová notácia %16.17.2











\section{\JS{} a jeho porovnanie s jazykom Dart}
V tejto podkapitole si predstavíme hlavné črty programovacieho jazyka \JS{}. 

JavaScript je objektovo orientovaný jazyk, ktorý upravuje internetové stránky v prehliadači a vykonáva výpočty v prehliadači.
(Skriptovací jazyk je programovací jazyk zameraný na výpočty a manipuláciu s objektami už existujúceho systému.)
Dnes je to plne vybavený všeobecne navrhnutý objektovo orientovaný programovací jazyk.
Okolo tohoto programovacieho jazyka sa vytvorila veľká komunita, ktorá udržiava tento jazyk stále živý a veľmi používaný.

Organizácia {ECMA International®} definuje špecifikácie aj tohoto jazyka. V súčasnosti je najnovší \JS{}, inak sa označuje aj ako 7. edícía. V tejto práci sa špecifikujeme na túto verziu jazyka, aj keď spomenieme niektoré vlastnosti, ktoré ešte nie sú v špecifikácii, ale sa pripravujú do ďalšej verzie. Presnú špecifikáciu možno nájsť v literatúre \cite[\JS{}]{ECMAScript}.
Do tejto práce boli informácie o JavaScripte čerpané najmä zo série kníh \cite[You Don't Know JS]{youDontKnowJS1, youDontKnowJS2, youDontKnowJS3, youDontKnowJS4, youDontKnowJS5, youDontKnowJS6}.
Pomenovania JavaScript a ECMAScript sú pre tento jazyk ekvivalentné.

\subsection{Triedy}
JavaScript má niektoré syntaktické prvky, ktoré sa spájajú s triedami, ako napríklad \emph{new}, \emph{class} alebo \emph{instanceof}. Avšak triedy ako také nemá. Na triedy sa môžeme pozrieť ako na návrhový vzor. 
\TODO{} class

\paragraph{Objekty}
Všetko v JavaScripte sú vlastne objekty a teda aj trieda je objekt. Funkcie, ktoré sú volané s kľúčovým \emph{new} sa bežne volajú konštruktory, aj keď v JavaScripte nevytvoria štandardnú triedu ako v iných triedovo orientovaných jazykoch. Ak hovoríme o inštancii triedy, myslíme tým kópiu daného objektu. Polymorfizmus na inštanciách triedy je opäť len výsledkom kopírovania vlastností. Preto aj odvodená trieda nemá odkaz na rodičovskú triedu, má od nej len nakopírované potrebné údaje.

\paragraph{Rozšírenia}
Mixin/extends pridáva špecifickú funkcionalitu z iného objektu. Pridáva ju kopírovaním. Avšak robí toto kopírovanie iba na prvej úrovni, teda ak hodnoty, ktoré sú ukladané pod kľúčmi nie sú primitívne, objekty, sú to objekty zdieľané referenciou. Čiastočne môžeme používať viacnásobné dedenie, ale nevyhneme sa kolíziám pri kopírovaní prvkov s rovnakým menom z viacerých zdrojov.

\paragraph{Prototype}
V JavaScripte existuje možnosť, ako previazať objekty medzi sebou. Každý objekt má vlastnosť prototype(predvolená hodnota je na Object.prototype). Táto vlastnosť nám umožňuje používať funkcie, ktoré sme objektu nešpecifikovali explicitne (napríklad funkcia toString).

Pomocou prototype môžeme robiť dedenie, ktoré sa veľmi podobá tomu z tried. Prototype nekopíruje, ale robí odkaz na objekt, "kam sa pozeráme, keď nevieme, aký objekt máme použiť".
Na programovanie v JavaScripte sa však môžeme pozrieť aj ako na delegovanie správania medzi objektami, namiesto dedenia medzi triedami.

\paragraph{Nový objekt}
Volanie funkcie s kľúčovým \emph{new} vytvorí nový objekt a vykoná telo funkcie. Funkcia ktorá je volaná ako konštruktor, nie je ničím iná od obyčajnej funkcie a každá môže vytvoriť objekt.
Ak tejto funkcii pridáme prototype, budú ho mať všetky z nej odvodené objekty. Funkcia, ktorú nastavíme pre prototype sa nekopíruje medzi ostatné objekty, ale je zdieľaná.
Ak chceme, aby program pridal linku na iný objekt (prototype) za nás, môžeme namiesto kľúčového slova \emph{new} použiť funkciu \emph{Object.create(\ldots)}, ktorá vytvorí objekt za nás.

\paragraph{}
O objektoch, ich prototypoch a rozšíreniach podrobnejšie možno nájsť informácie v knihe \cite[this \& Object Prototypes]{youDontKnowJS3}.

\subsection{Typy}
Jazyk \JS{} nie je typovaný jazyk. Napriek tomu rozlišuje niekoľko základných typov, na ktorých má definované konkrétne operácie. Typy jazyka ECMAScript sú \emph{Undefined}, \emph{Null}, \emph{Boolean}, \emph{String}, \emph{Symbol}, \emph{Number} a \emph{Object}. Každá hodnota premennej v tomto jazyku je charakterizovaná jedným z uvedených typov. V JavaScripte nemajú typ premenné, ale hodnoty premenných, ktoré sú v nich uložené. 

\begin{itemize}
  \item \emph{Primitívne typy} sú string, number, boolean, symbol, null, undefined a object
  \item \emph{Objekty} sú ostatné typy. Každý primitívny typ má aj svoj objektový ekvivalent, na ktorom môžeme robiť operácie(napríklad zistiť dĺžku stringu). Funkcia je objekt, ktorý obsahuje aj vykonateľné príkazy. Ďalšie objekty sú napríklad Array, Date, RegExp alebo Error.
\end{itemize}

\paragraph{Objekty}
Objekty vieme definovať priamo, teda vymenovaním obsahu, alebo cez kľúčové \emph{new}. Obe metódy vytvoria rovnaký objekt. Všeobecne sa preferuje definovanie vymenovaním prvkov.
Obsah objektu môžeme plniť viacerými možnosťami. Vymenovaním (riadok 4), cez bodku (riadok 7 a 9) alebo cez hranaté zátvorky (riadok 8 a 10). Platí, že keď používame bodkovú konvenciu, môžeme mená kľúčov nazývať iba jednoslovnými názvami bez medzier a špeciálnych znakov. Do hranatých zátvoriek môžeme dať ľubovolný string vrátane medzier. Ak chceme použiť ako kľúč hodnotu premennej, musíme použiť hranaté zátvorky. Použitím rovnakého kľúča cez bodku aj v hranatej zátvorke sa dostaneme ku rovnakej hodnote.

\begin{lstlisting}[caption=tvorba objektu]
  var objectString = new String("I am String");
  var primitiveString = "I am primitive string";

  var myObject = {
    key1: 'value1';
  }
  myObject.key2 = primitiveString;
  myObject["with space!"] = 'value2';
  console.log(myObject.key1); // 'value1'
  console.log(myObject["with space!"]); // 'value2'
\end{lstlisting}

\paragraph{Undefined} typ má práve jednu hodnotu \emph{undefined}. Každá premenná, ktorá nemá priradenú žiadnu hodnotu, ale je vytvorená, má práve túto hodnotu.

\paragraph{Null} typ má práve jednu hodnotu, \emph{null}. \emph{Null} predstavuje prázdny objekt. Od \emph{undefined} sa líši tým, že \emph{null} môže byť priradený ako hodnota do premennej.

\paragraph{This}%TODO mozno to ma vacsiu dolezitost?
Kľúčové slovo \emph{this} má v JavaScripte svoje špeciálne miesto. V iných jazykoch je to obvykle objekt, v ktorom sa nachádzame, definoval ho autor pri písaní kódu (author-time binding). V JavaScripte je to objekt, ktorý volal náš objekt a je definovaný počas behu programu (runtime binding). \emph{This} ukazuje väčšinou na miesto, odkial bola daná funkcia volaná, teda keď sa pozrieme do zásobníka volaní, bude to funkcia, ktorá je hneď pred našou.

Pri určovaní hodnoty premennej \emph{this} sa používajú tieto štyri pravidlá:
\begin{itemize}
  \item Štandardné viazanie premennej this (\emph{default binding}) predstavuje miesto, odkial bola funkcia volaná. V striktnom móde štandardné nastavenie this nefunguje.
  \item Implicitné viazanie premennej this (\emph{implicit binding}), ak voláme metódu na objekte v danom čase, this ukazuje na daný objekt
  \item Explicitné viazanie premennej this (\emph{explicit binding}) vznikne použitím funkcie \emph{call()} alebo \emph{apply()} kde ako prvý parameter dáme odkaz na \emph{this} ktorý chceme využiť. Podskupinou je zviazanie napevno (\emph{hard binding}), kde spravíme wrapper okolo funkcie, ktorá nastaví hodnotu this na danú nemmennú hodnotu určenú argumentom. od verzie ES6 existuje metóda \emph{bind()} pre funkcie ktorá robí \emph{hard binding}
  \item Viazanie premennej vytvorením nového objektu pomocou kľúčového slova \emph{new} (\emph{new binding}), vytvorí sa nová inštancia objektu, ktorá má v čase vykonávania this nasmerované na seba
\end{itemize}

Špeciálne správanie majú \emph{arrow functions}, kde sa \emph{this} správa ako štandardné, ktoré poznáme z iných programovacích jazykov. V takejto funkcii this odkazuje na seba.
\TODO{}
link na funkcie

\paragraph{}
Podrobnejšie informácie o typoch možno nájsť v knihe \cite[Types \& Grammar]{youDontKnowJS4}, o \emph{this} v knihe \cite[this \& Object Prototypes]{youDontKnowJS3}.

\subsection{Premenné}
%Na typ konkrétnej premennej sa môžeme pýtať príkazom
\TODO{}
ak je v normálnom, a má danej premennej priradiť hodnotu, vytvorí ju ako globálnu
ak je v striktnom móde behu programu, globálnu premennú nevytvorí ale vyhodi ReferenceError
TypeError vráti, ak napríklad objekt zavoláme ako funkciu, on nájde daný objekt ale danú operáciu s ním nevie vykonať. ReferenceError vyhodí, ak premennú nenájde a je v striktnom behu programu.

ReferenceError is Scope resolution-failure related, whereas TypeError implies that Scope resolution was successful, but that there was an illegal/impossible action attempted against the result.

\paragraph{Deklarovanie premenných v \JS{}}
\JS{} podporuje primárne tri typy deklarovania premenných. Sú to \emph{var}, \emph{const} a \emph{let}. 

V prípade \emph{const} a \emph{let} ide o premenné, ktoré sa nedajú deklarovať dvakrát s rovnakým menom a platia len vrámci daného bloku kódu. V štandardnej terminológii by sme ich mohli nazvať aj lokálne premenné. 

Deklarovanie kľúčovým \emph{let} nám zabezpečí, že pôsobnosť premennej je iba v aktuálnom najmenšom bloku ohraničenom zátvorkami \emph{\{\}}. Užitočnosť \emph{let} môžeme vidieť napríklad aj v cykloch \emph{for(let i = 0, \ldots)\{\}}.

Narozdiel od týchto, premennú \emph{var} môžeme deklarovať aj viackrát a môžeme sa na ňu pýtať aj mimo bloku kde sme ju deklarovali. V ukážke vidíme viacnásobné deklarovanie, volanie premennej mimo bloku, kde bola zavolaná aj volanie premennej predtým, ako bola vytvorená. Tieto premenné by sme mohli nazvať aj globálne premenné. 

Ak sa vyskytne v kóde premenná, kompilátor hľadá, kde bola definovaná. Ak ju nenájde, vytvorí novú premennú s daným menom ako globálnu. Ak beží tento skript v prehliadači, môžeme sa na túto premennú pozrieť aj ako na premennú daného okna, a pristupovať ku nej nasledovne \emph{window.meno\_premennej}. (Takto v ukážke funguje premenná \emph{k}.)

\begin{lstlisting}[caption=JavaScript deklarovanie]
  var i = 2;
  if (i >= 0) {
    console.log( i, j ); // i = 2 , j = undefined
    var j = 5;
    var i = 3;
    k = 10;
  } else {
    var j = 4;
  }
  console.log( i, j, k ); // i = 3 , j = 5 , k = 10
\end{lstlisting}

\subsection{Funkcie}
\TODO
%TODO funkcia deklarovaná ako konštanta z anonymnej funkcie

\subsection{Upozornenia a chyby}
\TODO
Strict mode
- podporovaný rôzne rôznymi prehliadačmi
- mení niektoré tiché chyby, tým že spraví throws  ...mistakes -> errors%TODO hrozná konštrukcia
- zabraňuje niektorým chybám, aby engine ktorý kompiluje a vykonáva kód, mohol lepšie optimalizovať
- zakazuje niektoré syntaktické konštrukcie(napríklad definovať viackrát rovnakú premennú, alebo priradiť hodnotu neexistujúcej premennej)
- pridáva nové rezervované slová (implements, interface, let, package, private, protected, public, static, and yield)

- má dosah na funkciu alebo na celý skript
- zapína sa príkazom \emph{'use strict';} na začiatku funkcie/skriptu

% zdroj https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode

\subsection{Súkromie}
\JS{} nemá rôzne úrovne súkromia. Verejné objekty z daného súboru sú len tie, ktoré sú označené kľúčovým slovom \emph{export} alebo \emph{export default}.
\TODO

\subsection{Knižnice}
\TODO import, export

\subsubsection{Dostupnosť}
Pre jazyk \JS{} je dostupné množstvo knižníc. Veľká časť z nich je dostupná cez správcu npm. Vkladanie knižnice do projektu je veľmi jednoduché volanie príkazu npm s vhodnou kombináciou prepínačov. (Volanie funkcie z priečinka projektu s prepínačom \emph{--save} bolo u nás postačujúce.)

\subsection{Súbežnosť}

Pri programovaní webových aplikácií potrebujeme písať asynchrónny kód (napríklad dotazy na server). Nemôžeme si dovoliť čakať na odpoveď, ktorá trvá dlho (a ani nevieme, či príde). Potrebujeme reagovať na používateľa.
JS beží v prehliadači, on rozhoduje o tom, čo je kedy vykonané, často je kód vykonaný sekvenčne (za sebou), nie paralelne.

\paragraph{Callback a Promise}
\emph{Callback} (spätné volanie) je funkcia, ktorá sa zavolá, keď sa daný kód vykoná. \emph{Callback} nie je úplne spoľahlivé riešenie. Preto potrebujeme nástroj na ktorý sa môžeme spoľahnúť. 
\emph{Promise} (prísľub) vykonáva asynchrónny kód. 
\emph{Promise} je typ objektu, ktorý nám sľubuje, že keď sa dokončí kus asynchrónneho kódu, hodnota \emph{promise} sa doplní vypočítanou. 
Je \emph{thenable}, čo znamená, že na ňom môžeme zavolať metódu \emph{then}, ktorá sa vykoná vtedy, keď sa naplní \emph{promise}. Poskytuje nám spôsob, ako spracovať neúspešný pokus o vykonanie kódu. 
Podobne ako \emph{then} použijeme \emph{catch} funkciu, ktorá odchytí chybovú hlášku, ak nejaká nastala. Malo by platiť, že vždy sa vykoná vetva \emph{then} alebo vetva \emph{catch}.
Alternatívne môžeme definovať \emph{promise} s jednou funkciou, ktorá spracuváva aj úspešný aj neúspešný výsledok (\emph{new Promise(function(resolve, reject)\{\ldots\})}).
\emph{Promise} sa nevyhýba callbackom, ale vhodne ich zaobaľuje, aby sa s nimi spoľahlivo pracovalo.

\emph{Promise} vie čakať na viac hodnôt (\emph{Promise.all([\ldots])})
alebo na prvú z množiny (\emph{Promise.race([\ldots])}).
Promises môžeme reťaziť za sebou. To nám umožňuje rozmýšľať nad asynchrónnymi operáciami sekvenčne.

\begin{lstlisting}[caption=Promise]
  const promise = fetch(serverUrl);

  promise
    .then(response => console.log(response))
    .catch(error => console.log(error));
\end{lstlisting}

\paragraph{Generátory}
\emph{Generátor} je funkcia, ktorá generuje niekoľko hodnôt a možno cez tieto hodnoty iterovať. Ku jednotlivým hodnotám sa dostaneme cez volanie funkcie \emph{next()} na danom generátore. 

Je to špeciálna funkcia, ktorá obsahuje niekoľko volaní \emph{yield}, ktoré pozastavia vykonávanie funkcie a voliteľne vrátia hodnotu ako argument tohoto volania. 
Ak chceme pokračovať vo vykonávaní tejto funkcie, zavoláme na generátore funkciu \emph{next()} s voliteľnými argumentami, ktoré sa potom do kódu doplnia namiesto kľúčového slova \emph{yield}.

\begin{lstlisting}[caption=Generátor]
  var it = function *foo(){
    let a = 1;
    a += yield a;
    yield a;
    return a*a;
  }

  it.next(); // spusti funkciu od zaciatku, 3. riadok vrati 1
  it.next(2); // do riadku 3 sa namiesto yield doplni 2, 4. riadok vrati 3
  it.next(); // return vrati poslednu hodnotu (9) a nastavi flag done=true
\end{lstlisting}

\emph{Generátor} môžeme využiť pri vykonávaní asynchrónneho kódu napríklad keď čakáme na odpoveď zo servera. Hlavná funkcia \emph{yield}-ne request na server a keď je hotový, hlavná funkcia bude zavolaná a do nej doplnená odpoveď cez argument funkcie \emph{next()} (hlavná funkcia sa správa ako generátor).

\paragraph{async a await}
Štruktúry, ktoré nepatria do špecifikácie \JS{} ale mali by byť v nasledujúcich verziách (pripravuje sa špecifikácia ôsmej edície) sú \emph{await} a \emph{async}. 
Tieto štruktúry schovávajú prácu s \emph{promise}-mi a \emph{generátor}-mi a uľahčujú logiku volania asynchrónnych funkcií.
\emph{Async} označuje funkciu, ktorá je vykonávaná asynchrónne, a môže obsahovať volanie \emph{promise}, na ktorý treba čakať.
Kľúčové slovo \emph{await} označuje miesto volania asynchrónneho kódu. Pri použití \emph{await} sa vykonávanie funkcie pozastaví a čaká sa na dokončenie \emph{promise}, ku ktorému patrí.

% TODO zdroj?
%https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await
%https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function

\paragraph{Web Workers}
JavaScript je jednovláknový jazyk. Niektoré prehliadače však poskytujú nástroj (\emph{Worker}), ako vykonávať úlohy vo viacerých vláknach paralelne (\emph{task paralelism}). Tento nástroj sa v praxi používa na vykonávanie ťažkých matematických operácií, prácu a triedenie veľkých dát alebo spravovanie veľkého množstva komunikácie.

\paragraph{}
Viac o asynchrónnom programovaní sa možno dočítať v knihe \cite[Async \& Performance]{youDontKnowJS5}.

\section{Spoločné znaky jazykov Dart a \JS{}}
Spoločné črty programovacích jazykov Dart a \JS{}. Pravdepodobne odkaz na tabuľku s podrobnejším popisom vybraných spoločných a rozdielných príkazov. \TODO

\paragraph{Postrehy pri písaní}
\emph{Mixiny} som nahradila čistými funkciami, ktoré som dala do samostatného súboru a vytvorila tak malú knižnicu funkcií.
Nevýhodou pri používaní funkcií namiesto mixinov je nemožnosť využiť gettery. Všetky hodnoty, ktoré chceme použiť vrámci jednej funkcie musíme mať ako vstupné parametre funkcie.

\paragraph{Podpora jazykov na rôznych systémoch}
Dostupnosť jazykov Dart a \JS{} je rôzna. Zatiaľ čo jazyk JavaScript vie (takmer) každý prehliadač reprezentovať priamo, jazyk Dart je potrebné v produkcii prekladať do jazyka JavaScript (Pri vývoji aplikácie v Darte je možné použiť špeciálny prehliadač na tento jazyk).

Jazyk JavaScript (\JS{}) vie bežať v prehliadači. Správanie prehliadačov sa však môže mierne líšiť.
%TODO

\input tabulkaPorovnania.tex

\begin{comment}
\section{Rozdiely a ich prepojenie}
Rozdielne časti daných jazykov a návrh riešenia, ako by sa dali nahradiť. Využitie zaujímavých čŕt jazyka \JS{}.
%(malé množstvo knižníc!!)

npm vs. pub
\end{comment}